/*      MyFuncs.h               agcr                12/5/91             *//*        Functions header file. Designed for use with the gcc ansi compiler.Contents:        Typedefs        My Utilities         Neural Networks Applications*//* *** My Utilities. *** *//* In SimpleMaths.c */int RoundUp(double x);int Round(double x);/* In MoreMaths.c */double Sigmoid(double x, double k);double Polynomial(double x, int numP, double *params);                                /* Returns : params[0] + x*params[1] + (x^2)*params[2] + ... (x^(numP-1))*params[numP-1]                                     NOTE the degree of the poly'l is 'numP-1'                                     and NOT 'numP' *//* In Combinatorics.c */int Choose(int total, int sample);                                /* returns no. of ways of coosing sample items                                     from total                                 = total!/(sample! * (total-sample)! ) */int Factorial(int num);         /* returns num! */int Power(int base, int indx);  /* returns base^index */double DPower(double x, double y);                                /* Same as Power() but for doubles *//* In BitOps.c */int Hamming(Bool a, Bool b);    /* Hamming distance between bits in                                     two unsigned integers */int HammingImages(Bool *im1, Bool *im2, int length);                                /* Hamming distance between two binary patterns                                    of the same length */Bool Pack(int len, Bool *list);                                 /* pack binary string into unsigned int */Bool MakeAddress(int arity, int *mapping, Bool *retina);                                /* make address out of retina using offsets */int HammingComparator(int *im1, int imSize, int *examples, int numExs);								/* return closest of examples to im1 */                                /* In Sort.c */void BubbleSort(char *table, int numRecords, int recordSize, int (*compFunc)());                                /* Lousy sorting program. Uses 'compFunc()' to                                     compare records in an array. Needs to know                                     how many there are and how big (where to                                     look for the next one). Watch this space                                    for QuickSort() and ShellSort() *//* In FitData.c */void AbsAreaMean(double xMin, double xMax, double yMin, double yMax, double *mean, double *sd, double (*func)(), int numP, double *params);                                /* Polynomial fitting of data */void Extrema(double xMin, double xMax, double *yMin, double *yMax, double (*func)(), int numP, double *params);/* In Integrate.c : numerical integration */double Integrate(double minX, double maxX, double (*func)(), int numP, double *params);                                /* 4th order Simpson's rule. func() can have a                                     parameter list (e.g. Polynomial()                                     and coefficients ). */double IntegrateAbs(double minX, double maxX, double (*func)(), int numP, double *params);                                /* As Integrate() except integrating                                     DAbs(func(...)) between the limits *//*In File.c */FILE *FOpen(char *fileName, const char *openStr);/* In Mat.c */void SolveMatrix(int side, double **aMat, double *bMat);                                /* solves Ax = b : puts the result in b *//* In SolveMat.c */double SolveMat(double **aMat, int eqns, int vars, double *bArr);                                /* solves Ax = b : puts the result in b */                                /* uses Gaussian elimination with full  */                                /* pivoting.  Returns determinant of A. *//* In Random.c : pseudo-random number generator */void SeedRandoms(int iSeed);    /* Seed the r.n.g. with the time (iSeed<0) or                                     with a certain number for repeating                                     experiments involving random sequences. If                                     you forget then its done automatically. */ int RandomInt(int low, int high);                                /* Returns a rndom no. in the range [lo,hi] */double RanDouble(double lo, double hi);                                /* Returns a rndom no. in the range [lo,hi] */Bool ProbOf1(double prob);      /* return 1 with probability 'prob' else                                     return 0 */Bool RandomBit();               /* fast routine to return a random bit *//* In Cursor.c */void CursorHome(void);void MoveCursor(int x, int y);void ChangeCursor(int newCurs);void CursorBlank(void);void CursorResume(void);void ClearLines(int from, int to);/* In DefInput.c */char DefInput(const char *message,const char *choices, char deflt,Bool errorMessage);                                /* Prints 'message' and waits for user to type                                     in one of 'choices' or a carriage return                                     <CR> if 'deflt' is used and <CR> is one of                                     the choices.                                     if 'errorMessage' then it prints an error                                    message for bad input, otherwise it just                                     waits until the user gets it right.                                    Returns the choice (or default). */int DefInputInt(const char *message,int lo,int hi,int deflt, Bool errMess);                                /* Like DefInput() but for entering integers.                                    'deflt', if used, must be between 'hi' and                                     'lo'. */char DefInputAt(int x,int y, const char *message, const char *choices, char def, Bool errMess);int DefInputIntAt(int x, int y, const char *message, int lo, int hi, int def, Bool errMess);                                /* As DefInput() and DefInputInt() except you                                    get to choose where on the screen the                                     'message' gets printed. *//* In String.c */Bool StrDiff(char *ref1, char *ref2);Bool StrEqual(char *ref1, char *ref2);int StrLen(const char *name);int SwapStr(char *name1, char *name2);int IntPrintSize(int x) ;int StrStr(char *s1,char *s2);char *TxtEq(char *mess);char *SuperTxtEq(char *txtPtr, char *mess);char *StrCat(char *str, char *catPart);/* In Word.c */void ErrMessage(char *fileName, int line, char *theLine, char *theWord, char *message);int GetWord(char *theLine, char *theWord, int wordPos);/* In GetLine.c */void Clear(void);               /* clears the screen */void Bell(void) ;               /* makes the terminal beep */void Acknowledge(const char *string);                                   /* useful for debugging - halts program                                     execution and waits for user to type in <CR>                                    Better than just printf() which can happen                                    after subsequent statements have been                                     executed - you don't know where the bug                                     is. */ void Ack(const char *string);   /* abbreviated form of 'Acknowledge()' */int GetLine(char *s, int lim, FILE *fPtr);void NewLine(void);void ShowPtr(void *ptr);        /* Gives the value of the ptr or "NULL" *//* In GetAnyLine.c */int GetAnyLine(char **theLine, FILE *fPtr);                                /* Gets line from fPtr, allocates space and puts                                 in char **theLine, returns length or -length                                 if EOF. */int CharStr(char ch, char *str);/* In Malloc.c */void *Malloc(int bytes);int SpaceUsed(void);int ShowSpaceT(void);void Free(void *ptr, int bytes);void **AllocArray(int rows, int cols, int eltSize);void FreeArray(void **arr, int rows);void FreeRegArray(void **arr, int rows, int bytesPerRow);void *MallocT(int bytes, char *comment);void FreeT(void *ptr,int bytes);M_TREE *InitMalloc(void);void DumpMallocT(void);/* *** Neural Networks Applications *** *//* In Wisard.c */void MakeMapping(int *mapping, int mapSize, int retSize, int numToDo);void ClearDiscriminators(DConts *discrims, int locns);void MakeSquareData(Bool *egData, int retSize, int numToDo, int **wkSpace);void DrawSquare(int xStart, int yStart, int **wkSpace);void CopyWkSpace(int **wkSpace, Bool *egData);/*void TrainDiscriminators(Wisard *wis);DConts DoTrain(Wisard *wis);void MakeAddresses(Wisard *wis);void DoAddressTrain(Wisard *wis);*/DConts DoTrain(DConts *discrim, Bool *egData, int *mapping, int numRams, int ntuple, int ramSize);void TrainDiscriminators(DConts *discrims, int discrimSize, int numDiscrims, int *mapping, int mapSize, Bool sameMaps, Bool *trainData, int retSize, int numRams, int ntuple, int ramSize);void MakeAddresses(Bool *egData, int *mapping, Bool *addresses, int numRams, int ntuple);void DoAddressTrain(DConts *discrim, Bool *addresses, int numRams, int ramSize);/* In Reverse.c *//* void DReverseDiscrim(Wisard *wis);void ReverseDiscrim(Wisard *wis);void AllReverseDiscrim(Wisard *wis);void ShowRetina(Wisard *wis);*/void DReverseDiscrim(double *reverse, int retSize, DConts *discrim, int *mapping, int mapSize, int numRams, int ntuple, int ramSize, double normal);void ReverseDiscrim(double *reverse, int retSize, DConts *discrim, int *mapping, int mapSize, int numRams, int ntuple, int ramSize, double normal);void AllReverseDiscrim(int retSize, DConts *discrim, int discrimSize, int numDiscrims, int *mapping, int mapSize, Bool sameMaps, int numRams, int ntuple, int ramSize, double normal, int nCols, FILE *outFile);/* In Response.c *//* DConts GetResponse(Wisard *wis);DConts GetAddressResponse(Wisard *wis);void TestDiscriminators(Wisard *wis);void TestWithNoise(Wisard *wis);int HighestResponse(Wisard *wis)*/void MakeNoisy(Bool *testData, int retSize, Bool *noisy, int level);DConts GetResponse(DConts *discrim, Bool *testData, int *mapping, int numRams, int ntuple, int ramSize);DConts GetAddressResponse(DConts *discrim, Bool *addresses, int numRams, int ramSize);void TestWithNoise(DConts *discrims, int discrimSize, int numDiscrims, Bool *egData, int retSize, int *mapping, int mapSize, Bool sameMaps, int numRams, int ntuple, int ramSize);int HighestResponse(DConts *discrims, int discrimSize, int numDiscrims, Bool *testData, int retSize, int *mapping, int mapSize, Bool sameMaps, Bool *addresses, int numRams, int ntuple, int ramSize);void TestDiscriminators(DConts *discrims, int discrimSize, int numDiscrims, Bool *testData, int retSize, int numTestEgs, int *mapping, int mapSize, Bool sameMaps, Bool *addresses, int numRams, int ntuple, int ramSize);/* In Gram.c */void ClearGram(DConts *discrims, int locns);/*void TrainGram(Wisard *wis);DConts DoGramAddressTrain(Wisard *wis);DConts DoGramTrain(Wisard *wis);DConts DoGramAddressTrain(Wisard *wis);void SpreadGram(Wisard *wis);void TestGram(Wisard *wis);void TestGramWithNoise(Wisard *wis);*/void TrainGram(DConts *discrims, int discrimSize, int numDiscrims, int *mapping, int mapSize, Bool sameMaps, Bool *trainData, int retSize, Bool *addresses, int numRams, int ntuple, int ramSize, int trainSignal);DConts DoGramAddressTrain(DConts *discrim, Bool *addresses, int numRams, int ramSize, int trainSignal);DConts DoGramTrain(DConts *discrim, Bool *eGdata, int *mapping, int numRams, int ntuple, int ramSize, int trainSignal);void SpreadGram(DConts *discrim, int numRams, int ntuple, int ramSize);void TestGram(DConts *discrims, int discrimSize, int numDiscrims, Bool *testData, int retSize, int numTestEgs, int *mapping, int mapSize, Bool sameMaps, Bool *addresses, int numRams, int ntuple, int ramSize);void TestGramWithNoise(DConts *discrims, int discrimSize, int numDiscrims, Bool *egData, int retSize, int *mapping, int mapSize, Bool sameMaps, int numRams, int ntuple, int ramSize);/* In ShowSubs.c */void ShowResponses(int *responses, int numToDo, int rows, int cols, int numNodes, FILE *fPtr);void ResponseAsterisks(double response, int numStars, FILE *fPtr);void ShowInts(int *list, int length, int rows, int cols, FILE *fPtr);void ShowRetina(double *dRetina, int *iRetina, int retSize, int nCols, FILE *outFile);/* In SysMap.c */void SystematicMapping(int *mapping, int mapSize, int numToDo);/* In WisInit.c *//*void CalculateParameters(Wisard *wis);void AllocateWisard(Wisard *wis);void FreeWisard(Wisard *wis);*/void CalculateParameters(int ntuple, double *coverage, int retSize, int *numRams, int *mapSize, int *discrimSize, int *ramSize, double *normal);void AllocateSpace(Bool sameMaps, int mapSize, int numDiscrims, int numRams, int discrimSize, int retSize, int numTrainEgs, int numTestEgs, int **mapping, Bool **addresses, DConts **discrims, Bool **trainData, Bool **testData);void FreeSpace(Bool sameMaps, int mapSize, int numDiscrims, int numRams, int discrimSize, int retSize, int numTrainEgs, int numTestEgs, int *mapping, Bool *addresses, DConts *discrims, Bool *trainData, Bool *testData);/* In CCEReverseSubs.c */void CCEController(int pixel, double *dRetina, int *iRetina, int retSize, int *mapping, DConts *discrim, int ramSize, int numRams, int ntuple, int nCols, FILE *outFile, double th);void CCEReverse(int pixel, double *dRetina, int *iRetina, int retSize, int *mapping, int numRams, int ntuple, DConts *discrim, int ramSize, int nCols, FILE *outFile, double th);/*DConts ReverseRAM(DConts *discrim, int ramSize, int *mapping, int ntuple, double *dRetina, int *iRetina, int addr, int line, double th);*//*double AddState(DConts aVal, double state, int bit);*/int ChThresh(double val, double th);double FullReverse(double *retina, int *iRetina, DConts *discrim, int numRams, int ramSize, int ntuple, int *mapping, int *frequencies, int numFreqs, double th);/* in Struct.c */void CopyPtr(void *from, void *to, int numBytes);/* in ConnectedMapping.c */int MakeConnectedMapping(int **map, int retSize, int ntuple );