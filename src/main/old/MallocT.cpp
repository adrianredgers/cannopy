/*      Malloc.c            AGCR            16/5/91                     *//***************************************************************************** *                                                                           * *                           MallocT() utilities.                            * *                                                                           * *****************************************************************************/#include <stdio.h>//#include "Adrian.h"// #include "SysFuncs.h"//#include "MyFuncs.h"/*      Adrian.h        AGCR        31/1/89                     *//*                                                              *//*                  General Inclusions File                     *//*                                                              */#include <stdio.h>#include <math.h>/* *** CONSTANTS *** *//* This File is Present */#define ADRIAN_H        1/* System Stuff */#define SCREENWIDTH     80#define TABSTOP         4#define MAXENTRY        255#define BELL            '\a'#define PRINTING_CHAR   32#define WORD_SIZE       8           /* one day it will increase... *//* Stuff for PLN's and GRAM's*/#define ONE             2#define ZERO            0#define U               1#define HIGHFLAG        16          /* Sets 5th bit high for updating Grams */#define LO              -1#define HI              1#define REWARD          1#define PUNISH          -1/* Printing stuff */#define chOne           '1'#define chZero          '0'#define chU             '.'#define MSB             10000#define MSB_2           (MSB/2)/* Numerical Constants */#define PI              3.14159265385#define E               2.718281828#define TOL             0.0000001  /* For comparing float's or double's */#define BIG             100000000   /* looks pretty big to me... */#define RANDOMBIT       RandomBit()                                    /* different each time it's called *//* *** C ALIASES *** */#define FOREVER         for(;;)/* Flags */#define TRUE            1#define FALSE           0#define UNSET           2           		/* BEWARE: "if(UNSET)" is true! */#define NOWORD          -1          		/* no word found in line by                                        		subroutine getword() *//* Comparison Operators - resembling FORTRAN */#define EQ ==#define NE !=#define GT >#define LT <#define GE >=#define LE <=#define NOT !#define AND &&#define OR ||#define LNOT !              				/* L for LOJIKAL */#define LAND &&#define LOR ||#define BNOT ~								/* B for BIT */#define BAND &#define BOR |#define BXOR ^/* *** MACROS *** *//* NOTE:    "###" <- means BEWARE argument(s) may be evaluated twice   *//* Bit Operations *//* NOTE:    j = i<<3    =>   j= i*8 (multiply by 8):   a<<b = a*(2^b)  *//*          A and B start from 0                                       */#define BitOf(A,B)  (((B)&(1<<(A)))>>(A))                                    /* ### Returns A'th bit of B ### */#define FlipBit(A,B)    ((B)^(1<<(A)))                                    /* Flips A'th bit of B */#define IsOn(A,B) ((B)&(1<<(A))) 	/* true if A'th bit of B is set */#define Pow2(A) (1<<(A))            /* 2^A = num locations in a RAM etc *//* Simple Maths Functions */#define Max(A,B)        ((A)>(B) ? (A) : (B))                                    /* ### */#define Min(A,B)        ((A)<(B) ? (A) : (B))                                    /* ### */#define Thresh(A)       ((A)>0 ?  1 : 0)                                    /* Threshold function */#define Abs(A)          ((A)>0 ? (A) : -(A))                                    /* ### Absolute value of A ### */#define Equal(A,B)  (Abs((A)-(B)) < TOL ? TRUE : FALSE )#define Sgn(A)          (Equal((A),0) ? 0 : ( (A) > 0 ? 1 : -1 ))#define DoFunc(A,B,C,D) ((C) ? ((B)((A),(C),(D))) : ((B)((A))))                                    /* ### Evaluating functions with variable                                        numbers of arguments ### *//* eg1 DoFunc(x,Poly,4,params) => (4)? => ((Poly)((x),(4),(params)))   eg2 DoFunc(x,sin,0,NULL) => (0)? => ((sin)(x))                       *//* *** Typedef's **** */typedef unsigned int Bool;  /* for use when we don't want signs                               getting in the way (e.g with bit operations).                               Don't forget to use %u in printf() statements. *//* Discriminator contents type */typedef int DConts;/*typedef double DConts;*//* *** STRUCTS *** */struct CharList{ /* struct for making a linked list of char's (or int's) */    char ch;                         /* this character */    struct CharList *next;          /* pointer to next character in the list */};typedef struct{    double  (*func)();    int     nump;    double  *params;    char    *funcName;} Function;/* To save on parameter passing: */typedef struct{    int ntuple;                         /* ntuple size */    int ramSize;                        /* = 1<<ntuple */    DConts *nodes;                      /* discriminator contents */    int discrimSize;                    /* = numRams*ramSize */    int numRams;                        /* numRams in the discriminator */    int numDiscrims;                    /* in the network */} Discriminator;typedef struct{	double (*squash)();					/* pointer to squashing function */	double lambda;						/* steepness param for squash fn */    int numActivns;                     /* no. activn states - default 2 */    double *activnProb;                 /* list of activation probs */	int middleVal;						/* middle activation value */} ActivationFunc;typedef struct{    int *list;                       	/* storage for mapping */    Bool sameMaps;                  	/* if so then can optimize */    int *address;                       /* optimizing sameMappings */    int mapSize;                        /* size of mapping */    double coverage;                    /* default = 1.0  = 100% */    int numMaps;  		                /* in the network */} Mapping;typedef struct{    int nRows;                          /* in the image */    int nCols;                          /*  "  "    "   */    FILE *outFile;                      /* default output to stdout */} Display;typedef struct{    int retSize;                        /* size of input image */	int *inputs;						/* the retina */} Retina;typedef struct{    double *dRetina;                    /* for reversing */    int *iRetina;                       /*  "       "    */    int pixel;                          /* which pixel are we talking about */    double normal;                      /* normalization const for reversing */    double th;                          /* threshold for reversing */} Reverse;typedef struct{    int numEgs;                         /* no. of images to deal with */    int numToDo;                        /* no. of discrims to deal with */    DConts  start;    int offset;    int *retina;    int trainSignal;                    /* training signal - reward/punish */} AnnOp;typedef struct{	Discriminator *discrim;				/* discriminator info */	Reverse *reverse;					/* reversing */	Mapping *mapping;					/* the mapping */	Retina *retina;						/* retina */	Display *display;					/* the display */	ActivationFunc *activFunc;			/* activation function */	AnnOp *opInfo;						/* info about which / how many to do */    int wisardKind;                    	/* 0 = normal Wisard, ... */} Wisard;typedef struct M_T *M_TREE_PTR;         /* MallocT() utilities tree structure */struct M_T{ /* binary tree structure for MallocT() */    void *ptr;                              /* the pointer */    int nItems;                             /* no. of items in the array */    int gulp;                             	/* gulp sizeof(type) for arrays */    int nBytes;                             /* no. of bytes = nItems*gulp */    char *mesg;                             /* user's comment */    int mesLen;                             /* length of comment */    M_TREE_PTR bigger;                      /* ptr's bigger than this one */    M_TREE_PTR smaller;                     /* ptr's smaller than this one */    M_TREE_PTR prev;                        /* parent node (NULL for theRoot) */};typedef struct M_T  M_TREE;static M_TREE *mRoot = NULL;				/* root of the Malloc tree */static int userMem = 0;/* local subroutine declarations *///void ErrorT(char *errMesg,void *ptr,int numBytes,char *message, M_TREE *this, M_TREE *next);	/* error message, dump & exit */void PrintNodeT(M_TREE *thisTree, int spaces);void PrintSpacesT(int spaces);void DumpT(M_TREE *thisTree, int spaces);void AddToTreeT(M_TREE *bough, M_TREE **trunk);M_TREE *NewNodeT(void *p,int numBytes,char *message);M_TREE *FindBT(void *p, M_TREE *thisTree);M_TREE *FindT(void *p, int numBytes, M_TREE *thisTree);M_TREE *BalanceT(M_TREE *node);void *MallocT(int numBytes, char *message){    void *p;	M_TREE *this;    if(numBytes==0)        return(NULL);    if(numBytes<0)        ErrorT("MallocT: trying to Malloc negative no. of bytes",NULL,numBytes,message,NULL,NULL);    p = (void *) Malloc(numBytes);    userMem += numBytes;    this = NewNodeT(p,numBytes,message);    AddToTreeT(this,&mRoot);    return(p);}   /**** End of void *MallocT() ****/void ErrorT(char *errMesg, void *ptr, int numBytes, char *message, M_TREE *thisTree, M_TREE *next){ /* error report and diagnostic printout */    fprintf(stderr,"\n%s\n....",errMesg);   /* error report */    if(ptr!=NULL)        fprintf(stderr,"ptr=%d ", (int) ptr);    if(numBytes!=0)        fprintf(stderr,"numBytes=%d ",numBytes);    if(StrLen(message) > 0)        fprintf(stderr,"message='%s'",message);    PrintNodeT(thisTree, 0);    PrintNodeT(next, 0);    DumpMallocT();    exit(1);} /**** End of void ErrorT() ****/void PrintNodeT(M_TREE *thisTree, int spaces){    if(thisTree==NULL)        return;    fprintf(stderr,"\n");    PrintSpacesT(spaces);    fprintf(stderr,"node %d : ptr=%d nBytes=%d\n",(int) thisTree, (int) thisTree->ptr,thisTree->nBytes);    PrintSpacesT(spaces);    if(thisTree->mesg == NULL)        fprintf(stderr,"mesg=NULL mesLen=0\n");    else        fprintf(stderr,"mesg='%s' mesLen=%d\n",thisTree->mesg,thisTree->mesLen);    PrintSpacesT(spaces);    fprintf(stderr,"prev=");ShowPtr(thisTree->prev);    fprintf(stderr," bigger=");ShowPtr(thisTree->bigger);    fprintf(stderr," smaller=");ShowPtr(thisTree->smaller);} /**** End of void PrintNodeT() ****/void PrintSpacesT(int spaces){    while(spaces>0)    {        fprintf(stderr," ");        spaces--;    }} /**** End of void PrintSpacesT() ****/void DumpT(M_TREE *thisTree, int spaces){    if(thisTree==NULL)        return;    PrintNodeT(thisTree, spaces);    DumpT(thisTree->bigger, spaces+2);    DumpT(thisTree->smaller, spaces+2);} /**** End of DumpT() ****/void DumpMallocT(void){    fprintf(stderr,"\n\nDump of the M_TREE");    fprintf(stderr,"\n==================");    DumpT(mRoot,0);    fprintf(stderr,"\n===End of Dump ====\n");} /**** End of void DumpMallocT() ****/void AddToTreeT(M_TREE *bough, M_TREE **trunk){ /* add the bough to the trunk - update bough->prev */    M_TREE *above = NULL, *thisPos = *trunk;    Bool found = FALSE, bigFork = FALSE;	if(bough == NULL)		return;								/* nothing to add */    if(*trunk == NULL)    { /* trunk (mRoot) is NULL - make 'bough' the trunk */        *trunk = bough;        (*trunk)->prev = NULL;   		return;    }    while(!found)    { /* search the tree for a Free space to insert the bough */		if(thisPos == NULL)		{ /* found one */            thisPos = bough;				/* insert the node */			thisPos->prev = above;			/* update bough->prev */			if(bigFork == TRUE)				above->bigger = bough;			else				above->smaller = bough;            found = TRUE;		}		else		{ /* haven't found one - keep traversing the tree */			above = thisPos;            if(bough->ptr > thisPos->ptr)			{			    thisPos = thisPos->bigger;				bigFork = TRUE;			}            else if(bough->ptr < thisPos->ptr)			    thisPos = thisPos->smaller;            else                ErrorT("AddToTreeT: found ptr on the tree already",NULL,0,NULL,thisPos,bough);		} /* end of tree-traversal */    } /**** End of while() ****/} /**** End of void AddToTreeT() ****/M_TREE *NewNodeT(void *p, int numBytes, char *message){ /* make a new node */    M_TREE *this;    if((p==NULL)||(numBytes==0))        ErrorT("NewNodeT: trying to add NULL ptr or 0 bytes to tree", NULL,numBytes,message,NULL,NULL);    this = (M_TREE *) Malloc(sizeof(M_TREE));    this->ptr = p;    this->nBytes = numBytes;    this->mesg = TxtEq(message);    this->mesLen = StrLen(message);    this->bigger = NULL;    this->smaller = NULL;    this->prev = NULL;    return(this);} /**** End of M_TREE *NewNodeT() ****/void FreeT(void *p, int numBytes){    M_TREE *this, *above, *bough;    if(p == NULL)        if(numBytes==0)						/* that's cool - freeing 0 bytes */            return;							/* from a NULL pointer - I can 	 */	                                        /* handle that...idiot! 		 */        else            ErrorT("FreeT: cannot free bytes from NULL pointer",NULL,numBytes,NULL,NULL,NULL);    this = FindT(p,numBytes, mRoot);    if(this==NULL)        ErrorT("FreeT: could not find pointer",p,numBytes,NULL,NULL,NULL);    Free(this->ptr,this->nBytes);                        /* free up space */    userMem -= this->nBytes;    Free(this->mesg, this->mesLen*sizeof(char));	/* we have now freed up the allocated space, but 'this' is still intact */    /* tree balancing act with the children of 'this' */    AddToTreeT(this->smaller, &(this->bigger));											/* tag smaller on to bigger */    bough = BalanceT(this->bigger);         /* bough of balanced sub-tree */    /* add bough to 'above' */    above = this->prev;    if(bough != NULL)        bough->prev = above;                /* bough->prev = 'above' anyway */    if(above != NULL)    { /* 'this' is not mRoot */        if(above->bigger == this)           /* add balanced tree to main tree */            above->bigger = bough;        else if(above->smaller == this)            above->smaller = bough;        else            ErrorT("FreeT: freeing BYTES - ABOVE node doesn't contain THIS one",p,numBytes,NULL, above,this);    }    else    {   /* 'this' is mRoot - copy bough to mRoot */		mRoot = bough;		if(bough != NULL)		    mRoot->prev = NULL;    }    Free(this,sizeof(M_TREE));} /**** End of void FreeT() ****/M_TREE *BalanceT(M_TREE *this){    return(this);} /**** End of BalanceT() ****/M_TREE *FindT(void *p, int numBytes, M_TREE *thisTree){    M_TREE *next = NULL, *next2 = NULL;    if(thisTree->ptr == p)        if(thisTree->nBytes != numBytes)            ErrorT("FindT: found pointer but wrong no. of bytes",p,numBytes,NULL,thisTree,NULL);        else            return(thisTree);    /* didn't find p, search the sub-trees */    if(thisTree->smaller != NULL)        next = FindT(p, numBytes, thisTree->smaller);    if(thisTree->bigger != NULL)        next2 = FindT(p, numBytes, thisTree->bigger);    if(next==NULL) /* act on the results of the search */        return(next2);    else if(next2==NULL)            return(next);    else        ErrorT("FindT: found pointer twice",p,numBytes,NULL,next,next2);    return(NULL);} /**** End of FindT() ****/int ShowSpaceT(void){    fprintf(stderr,"\nuser memory = %d bytes, house-keeping = %d, total = %d\n",userMem,(SpaceUsed()-userMem), SpaceUsed());	return(userMem);} /**** End of void ShowSpace() ****/#define TEST_MallocT 2#if TEST_MallocT == 1int main(){char *p, *q, *r;p = (char *) MallocT(10, "test 1");q = (char *) MallocT(110, "test 2");printf("\np = %d, q = %d\n",(int) p, (int) q);Ack("just Malloced p and q");DumpMallocT();(void) ShowSpaceT();FreeT(p,10*sizeof(char));Ack("just Freed p");DumpMallocT();(void) ShowSpaceT();r = (char *) MallocT(30, "test 3");Ack("just Malloced r ");DumpMallocT();(void) ShowSpaceT();FreeT(q,110);Ack("just Freed q");DumpMallocT();(void) ShowSpaceT();FreeT(r,30);Ack("just Freed r");(void) ShowSpaceT();return(0);}#endif