/*      EBPSubs.c               AGCR            27/8/92             *//* Adrian Redgers created and reserves all rights to, but accepts no   responsibility for, this file. *//*  Offers of jobs or money gratefully recieved at:            28A Clarendon Road, London SW19 2DU, UK.	        Tel: (081) 543 1748 */#include "EBP.h"void SetUpNetwork(struct EBPNet *theNet, int whichNet){ /* declare and initialize components of theNet  */    /* NOTE: whichNet==1 -> emulator,   whichNet==2 -> controller    *//* *** NOTE:   ### YCSTY ###   means:  You Can Set This Yourself */     int i, j, nodes;    /* Set up the topology of the network */    if(whichNet == 1)        theNet->layers = 3;                 /* ### YCSTY ### */    else if(whichNet == 2)        theNet->layers = 3;                 /* ### YCSTY ### */    theNet->nodesPerLayer = (int *) malloc(theNet->layers*sizeof(int));    theNet->outputY = (double **) malloc(theNet->layers*sizeof(double *));    theNet->sumX = (double **) malloc(theNet->layers*sizeof(double *));    theNet->weight = (double ***) malloc(theNet->layers*sizeof(double **));    theNet->delta = (double ***) malloc(theNet->layers*sizeof(double **));/*  theNet->momentum = (double ***) malloc(theNet->layers*sizeof(double **));*/        /* the following do *not* include biases */    if(whichNet == 1)    { /* the emulator network */        theNet->nodesPerLayer[2] = 4;       /* ### YCSTY ### */        theNet->nodesPerLayer[1] = 45;      /* ### YCSTY ### */        theNet->nodesPerLayer[0] = 5;       /* ### YCSTY ### */    }    else if(whichNet == 2)    { /* the controller network */        theNet->nodesPerLayer[2] = 1;       /* ### YCSTY ### */        theNet->nodesPerLayer[1] = 25;      /* ### YCSTY ### */        theNet->nodesPerLayer[0] = 4;       /* ### YCSTY ### */    }    theNet->biasPresent = 1;                /* ### YCSTY ### */    theNet->update = BY_EXAMPLE;            /* ### YCSTY ### */    theNet->maxNodesPerLayer = 0;    for(i=0;i<theNet->layers;i++)    { /* sort out topology & allocate space - first pass */        theNet->nodesPerLayer[i] += theNet->biasPresent;        nodes = theNet->nodesPerLayer[i];        if(nodes > theNet->maxNodesPerLayer)            theNet->maxNodesPerLayer=nodes; /* max nodes in a layer */        theNet->outputY[i] = (double *) malloc(nodes*sizeof(double));                                            /* space for neuron responses */        theNet->sumX[i] = (double *) malloc(nodes*sizeof(double));                                            /* sums of weighted inputs */        theNet->weight[i] = (double **) malloc(nodes*sizeof(double *));                                            /* weights arrays */        theNet->delta[i] = (double **) malloc(nodes*sizeof(double *));   /*   theNet->momentum[i] = (double **) malloc(nodes*sizeof(double *));*/    } /* next i */    theNet->numInputs = theNet->nodesPerLayer[0];    theNet->numOutputs = theNet->nodesPerLayer[theNet->layers-1];    theNet->desired = (double *) malloc(theNet->numOutputs*sizeof(double));                                            /* space for desired outputs */    if(theNet->biasPresent)                 /* set up bias units */        for(i=0;i<theNet->layers-1;i++)            theNet->outputY[i][0] = 1.0;    /* zeroth unit in each layer */    for(i=1;i<theNet->layers;i++)           /* space for weights */        for(j=theNet->biasPresent;j<theNet->nodesPerLayer[i];j++)        {            theNet->weight[i][j] = (double *) malloc(/* CONT */ theNet->nodesPerLayer[i-1] * sizeof(double));            theNet->delta[i][j] = (double *) malloc(/* CONT */ theNet->nodesPerLayer[i-1] * sizeof(double));        /*    theNet->momentum[i][j] = (double *) malloc(				 theNet->nodesPerLayer[i-1] * sizeof(double));*/        }     nodes = theNet->maxNodesPerLayer;       /* space for alpha, beta */    theNet->alpha = (double *) malloc(nodes*sizeof(double));    theNet->beta = (double *) malloc(nodes*sizeof(double));    theNet->learnRate = 0.5 ;                /* ### YCSTY ### */   /* theNet->momLearn = 0.1;*/             /* ### YCSTY ### */    theNet->squash = Tanh;            		/* ### YCSTY ### */    theNet->dSquash = DiffTanh;       		/* ### Y Must STY ### */    /* parameters for squashing functions */    theNet->args.lim = 0.25;                /* ### YCSTY ### */    theNet->args.grad = 0.5/theNet->args.lim;            } /**** End of void SetUpNetwork() ****//* ============================================================== */double Propagate(struct EBPNet *theNet){ /* Propagate the example upwards from the retina, and store nodal responses.   Returns the squared error between the actual and desired outputs */    double sum;    int maxDowNodes, maxUpNodes = theNet->nodesPerLayer[0];      register int down, up, layer;           /* using registers is supposed to                                             speed things up, hahahahaha */    for(layer=1; layer<theNet->layers; layer++)    { /* Propagate up to the top */        maxDowNodes = maxUpNodes;        maxUpNodes = theNet->nodesPerLayer[layer];        for(up=theNet->biasPresent; up<maxUpNodes; up++)        { /* for each node on ths layer (except bias unit) */            sum = 0.0;            for(down=0 ;down<maxDowNodes; down++)                sum += theNet->outputY[layer-1][down] */* CONT */ theNet->weight[layer][up][down]; /* make the sum */            theNet->sumX[layer][up] = sum;              theNet->args.x = sum;           /* load up for squash() */              theNet->outputY[layer][up] = (*(theNet->squash))(theNet->args);          } /* next up */    } /* next layer */    /* Now calculate squared error, and alphas */    sum = 0.0;    for(up=theNet->biasPresent; up < theNet->numOutputs; up++)    {         theNet->alpha[up] = theNet->outputY[theNet->layers-1][up] -/* CONT */ theNet->desired[up];        sum += theNet->alpha[up] * theNet->alpha[up];    } /* next up */    return (sum*0.5); } /* end Propagate *//* ============================================================== */void BackProp(struct EBPNet *theNet)/* the back propagation algorithm */{double sum;int maxUpNodes;int maxDowNodes = theNet->nodesPerLayer[theNet->layers-1];register int down, up, layer; /* the Alpha's in the top layer have already been calculated using   the original error information during propagation */for(layer=theNet->layers-1; layer>0;layer--){ /* go from top layer down to bottom layer */    maxUpNodes = maxDowNodes;    maxDowNodes = theNet->nodesPerLayer[layer-1];                                             /*  'layer-1' is the layer below */    /* calculate all Beta's and Delta's for this layer */    for(up=theNet->biasPresent; up<maxUpNodes; up++)    {        theNet->args.x = theNet->sumX[layer][up];        theNet->args.y = theNet->outputY[layer][up];        theNet->beta[up] = theNet->alpha[up]*(*(theNet->dSquash))(theNet->args);        if(theNet->learnRate > 0.00001)     /* if rate>0  calc. changes */            if(theNet->update == BY_EXAMPLE)                for(down=0; down<maxDowNodes; down++)				{				/*	theNet->momentum[layer][up][down] = theNet->delta[layer][up][down] * theNet->momLearn;*/                    theNet->delta[layer][up][down] =  - theNet->learnRate */* CONT */ theNet->beta[up] * theNet->outputY[layer-1][down];				}            else                            /* updating BY_EPOCH */                for(down=0; down<maxDowNodes; down++)				{                    theNet->delta[layer][up][down] -=  theNet->learnRate */* CONT */ theNet->beta[up] * theNet->outputY[layer-1][down];				}	/*if((layer==theNet->layers-1) && (up==1))		printf("\nX: alph=%f, beta=%f, out=%f",theNet->alpha[up],theNet->beta[up], theNet->outputY[layer][up]); */    } /* next up */    /* calculate the Alpha's in the layer below - using the Beta's in the        layer above */    for(down=0; down<maxDowNodes; down++)    { /* for each node in the lower layer... */        sum = 0.0;        for(up=theNet->biasPresent; up<maxUpNodes; up++)        { /* go through the nodes in the layer above */            sum += theNet->beta[up] * theNet->weight[layer][up][down];            if((theNet->learnRate>0.00001) && (theNet->update == BY_EXAMPLE))                theNet->weight[layer][up][down] +=/* CONT */ theNet->delta[layer][up][down]; /*+ theNet->momentum[layer][up][down];*/                                            /* do it now since W[][][] is not                                            used again this back-propagation */        } /* next up */        theNet->alpha[down] = sum;    } /* next down */} /* next layer *//*     ORDINARILY (above): W(t+1) = W(t) + Delta     or MOMENTUM TERMS: W(t+1) = W(t) + Delta + k*(W(t) - W(t-1))                                                  ---------------                                                     ^^^ previous Delta    using a momentum constant k : 0<k<1   eg, k=0.01*/} /**** End of void BackProp() ****//* ============================================================== */void SetRandWeights(struct EBPNet *theNet){ /* sets them between -1.0 and 1.0  - arbitrary limits */    int layer,up, down;    int  maxDowNodes, maxUpNodes = theNet->nodesPerLayer[0];    for(layer=1; layer < theNet->layers; layer++)    {        maxDowNodes = maxUpNodes;        maxUpNodes = theNet->nodesPerLayer[layer];        for(up=theNet->biasPresent; up<maxUpNodes; up++)            for(down=0; down<maxDowNodes; down++)            {                theNet->weight[layer][up][down] = RanDouble(-1.0,1.0);                theNet->delta[layer][up][down] = 0.0;            /*  theNet->momentum[layer][up][down] = 0.0;*/            }    } /* next layer */} /**** End of void SetRandWeights() ****/void EpochUpdate(struct EBPNet *theNet) { /* change the weights, and clear the deltas,  at the end of an epoch */    int layer,up, down;    int  maxDowNodes, maxUpNodes = theNet->nodesPerLayer[0];    if(theNet->learnRate < 0.00001)        return;    for(layer=1; layer < theNet->layers; layer++)    {        maxDowNodes = maxUpNodes;        maxUpNodes = theNet->nodesPerLayer[layer];        for(up=theNet->biasPresent; up<maxUpNodes; up++)            for(down=0; down<maxDowNodes; down++)            {                theNet->weight[layer][up][down] += /* CONT */ theNet->delta[layer][up][down];                theNet->delta[layer][up][down] = 0.0;            }    } /* next layer */}   /**** End of void EpochUpdate()  ****//* ============================================================== */double ExpSigmoid(struct Args theArgs){ /* the squashing function y = 1/(1+exp(-x)) */    double exp();    return ( 1.0/(1.0+exp(-theArgs.x)) ); } /**** End of double ExpSigmoid() ****/double DiffExpSigmoid(struct Args theArgs){ /* differential of the squashing function y = 1/(1+exp(-x)) */    return ( theArgs.y*(1.0-theArgs.y) ); } /**** End of double DiffExpSigmoid() ****//* ============================================================== */double Tanh(struct Args theArgs){ /* squashing function y = tanh(x) */	double tanh();	return(tanh(theArgs.x));} /**** End of double Tanh() ****/double DiffTanh(struct Args theArgs){ /* differential of tanh */	return(1-theArgs.y*theArgs.y);} /**** End of double DiffTanh() ****//* ============================================================== */double RampThresh(struct Args theArgs){ /* ramp threshold function *//*   if       x < -lim    rt(x) = 0   else if  x >  lim    rt(x) = 1   else                 rt(x) = 1/2lim * x + 1/2    */    if(theArgs.x < -theArgs.lim)         return(0.0);    else    if(theArgs.x > theArgs.lim)         return(1.0);    else        return((theArgs.grad*theArgs.x)+0.5);} /* *** End of double RampThresh(x) *** */double DiffRampThresh(struct Args theArgs){ /* block delta function - derivative of RampThreshold() */    if((theArgs.x < -theArgs.lim)||(theArgs.x > theArgs.lim))         return(0.0);    else        return(theArgs.grad);               /* the block */} /**** End of double DiffRampThresh() ****//* ============================================================== */int CheckWithinBounds(double *outState){ /* check this state is within bounds */	int withinBounds=1;	outState[0] *= 200.0;	outState[1] *= 100.0;	outState[2] *= 180.0;	outState[3] *= 200.0;    if(outState[2] > outState[3] + 10.0)    /* cab angle is limited */        outState[3] = outState[2] - 10.0;    if(outState[3] > outState[2] + 10.0)        outState[3] = outState[2] + 10.0;           if( ((outState[1]*outState[1]) >2500.0) || (outState[0]<0.0) ||/* CONT */ (outState[0]>100.0) || (outState[2]*outState[2]>8100.0) )    	    withinBounds = 0;		outState[0] /= 200.0;	outState[1] /= 100.0;	outState[2] /= 180.0;	outState[3] /= 200.0;	return(withinBounds);}int PlantFunction(double *inState, double *outState){ /* given an input state, what is the next state? */	int withinBounds;    double  rMove = 0.2,                    /* move tyres per time unit */            dCab = 6.0,                     /* length of cab */            dTrailer = 14.0,                /* length of trailer */			x = inState[0]*200.0,			/* x coord of centre reer */				y = inState[1]*100.0,			/* y coord of centre reer */				thTrail = inState[2]*180.0,		/* trailer angle */			thCab = inState[3]*200.0,			/* cab angle */			thU = inState[4]*70.0;			/* steering angle */	double xDot, yDot;						/* differentials of x & y */    double  degToRad = 0.01745329252, radToDeg = 57.29577951;    double 	cThTrail = cos(degToRad*thTrail),            sThTrail = sin(degToRad*thTrail),            cThCab = cos(degToRad*thCab),            sThCab = sin(degToRad*thCab),            sThU = sin(degToRad*thU),            cThU = cos(degToRad*thU);    double  A = rMove*cThU,            B = A*cos(degToRad*(thCab-thTrail)),            C = A*sin(degToRad*(thCab-thTrail));	xDot = - B*cThTrail;	yDot = - B*sThTrail;    outState[0] = x + xDot;  		/* x coord of centre rear */    outState[1] = y + yDot;    		/* y coord of centre rear */    outState[2] = radToDeg*atan((dTrailer*sThTrail-C*cThTrail) //* CONT */ (dTrailer*cThTrail+C*sThTrail));  										 	/* trailer angle */    outState[3] = radToDeg*atan((dCab*sThCab-rMove*cThCab*sThU) //* CONT */ (dCab*cThCab+rMove*sThCab*sThU));                                            /* cab angle */    if(outState[2] > outState[3] + 10.0)    /* cab angle is limited */        outState[3] = outState[2] - 10.0;    if(outState[3] > outState[2] + 10.0)        outState[3] = outState[2] + 10.0;       /*				y bounds vvvv                     x bound vvvv  */     if( ((outState[1]*outState[1]) >2500.0) || (outState[0]<0.0) ||/* CONT */ (outState[0]>100.0) || (outState[2]*outState[2]>8100.0) )    /*              x bound ^^^^           thTrail bound ^^^^    */	{ /* out of bounds of the experiment *//*		printf("\nTruck crashed");*/		withinBounds = 0;		}    else		withinBounds = 1;		outState[0] /= 200.0;					/* scale to the range [-0.5,0.5] */	outState[1] /= 100.0;		outState[2] /= 180.0;	outState[3] /= 200.0;    return(withinBounds);} /**** End of int PlantFunction() ****/void DiffPlantFunction(double *prevU, double *actual, double *desired, double *alph){ /* truck has just crashed.  We have the state before it crashed and theprevious steering signal U .  */    double  rMove = 0.2,                    /* move tyres per time unit */            dCab = 6.0,                     /* length of cab */            dTrailer = 14.0;                /* length of trailer */    double  degToRad = 0.01745329252;	double	thTrail = actual[2]*180.0,	/* trailer angle */			thCab = actual[3]*200.0,		/* cab angle */			thU = prevU[0]*70.0;			/* steering angle */    double 	cThTrail = cos(degToRad*thTrail),            sThTrail = sin(degToRad*thTrail),            cThCab = cos(degToRad*thCab),            sThCab = sin(degToRad*thCab),            sThU = sin(degToRad*thU),            cThU = cos(degToRad*thU);    double  A = rMove*cThU,    		AA = rMove*sThU,            B = AA*cos(degToRad*(thCab-thTrail)),            BB = AA*sin(degToRad*(thCab-thTrail)),            C = A*sin(degToRad*(thCab-thTrail));	double  D, E, F, G, H, I;    D = atan((dTrailer*sThTrail-C*cThTrail) / (dTrailer*cThTrail+C*sThTrail));  										 	/* trailer angle */	E = cos(D);    F = ((dTrailer*cThTrail+C*sThTrail)*(BB*cThTrail) + (dTrailer*sThTrail-C*cThTrail) * (BB*sThTrail)  ) /    ((dTrailer*cThTrail+C*sThTrail) * (dTrailer*cThTrail+C*sThTrail));    G = atan((dCab*sThCab-rMove*cThCab*sThU) / (dCab*cThCab+rMove*sThCab*sThU));	H = cos(G);	I = ((dCab*cThCab+rMove*sThCab*sThU)*(-rMove*cThCab*cThU) - (dCab*sThCab-rMove*cThCab*sThU)*(rMove*sThCab*cThU))/ ((dCab*cThCab+rMove*sThCab*sThU) * (dCab*cThCab+rMove*sThCab*sThU));                                             /* cab angle *//*	printf("\nthU=%f, thTrail=%f A=%f AA=%f B=%f C=%f D=%f E=%f F=%f G=%f ",thU,thTrail,A,AA,B,C,D,E,F,G);*/	/* calculate dE/du and put it in alph[0] */	*alph  =  (B*cThTrail)*(actual[0]-desired[0]);/*	printf("\nalph=%f act[0]=%f des[0]=%f",*alph,actual[0],desired[0]);*/											/* diff x coord */	alph[0] +=  (B*sThTrail)*(actual[1]-desired[1]);											/* diff y coord *//*	printf("\nalph=%f act[1]=%f des[1]=%f",*alph,actual[1],desired[1]);*/	alph[0] +=  (E*E*F)*(actual[2]-desired[2]);											/* diff thTrailer *//*	printf("\nalph=%f act[2]=%f des[2]=%f",*alph,actual[2],desired[2]);*//*	alph[0] +=  (H*H*I)*(actua[3]-desired[3]);	*/											/* diff thCab */} /**** End of void DiffPlantFunction() ****/void LoadInState(double *inState, double *outState, int traj, int example){ /* create an inState to propagate up the network */    int i;	double xDot, yDot;						/* differentials of x & y */    if(example==0)    { /* new trajectory */        inState[0] = 30.0/200.0;            /* x coord of centre rear */        inState[1] = 2.0*traj/100.0;        /* y coord of centre rear */        inState[2] = traj*4.5/180.0;        /* angle of trailer */        inState[3] = traj*5.0/200.0; 		/* angle of cab */		xDot = 0.0;		yDot = 0.0;		inState[4] = 3.0*traj/70.0;			/* steering angle U */    }    else        for(i=0;i<4;i++)					/* copy across from outState */            inState[i] = outState[i];/*    inState[4] = RanDouble(-30.0,30.0)/70.0; *//*    inState[4] = 0.0/70.0; 			*/} /**** End of void LoadInState() ****/void LoadGoal(double *goal){	goal[0] = 0.0;							/* x desired */	goal[1] = 0.0;							/* y desired */	goal[2] = 0.0;							/* thTrailer desired */} /**** End of void LoadGoal() ****//* =========== Printing and Display Subroutines ===================== */void PrintToFile(struct EBPNet *theNet, double suberr, int try, int traj, int epoch, int point){    int bit;	FILE *fPtr;								/* file ptr for results */	fPtr = fopen("ErrResults","a");				/* open file for append */    fprintf(fPtr,"\ntraj =%3d,try =%2d ", traj, try);											/* print to the file */    printf("\nepoch=%3d,point=%2d", epoch, point);    if(theNet->biasPresent)        printf("  bias   ");    printf("    x        y    thTrailer  thCab   steering");    printf("\n         Inputs:  ");    for(bit=0; bit< theNet->numInputs;bit++)        printf(" %7.4f ",theNet->outputY[0][bit]);    printf("\nDesired outputs:  ");    if(theNet->biasPresent)        printf("  ----   ");    for(bit=theNet->biasPresent; bit< theNet->numOutputs; bit++)        printf(" %7.4f ",theNet->desired[bit]);    printf("\n Actual outputs:  ");    if(theNet->biasPresent)        printf("  ----   ");    for(bit=theNet->biasPresent; bit< theNet->numOutputs; bit++)        printf(" %7.4f ",theNet->outputY[theNet->layers-1][bit]);    printf("\n         Errors:  ");    if(theNet->biasPresent)        printf("  ----   ");    for(bit=theNet->biasPresent; bit< theNet->numOutputs; bit++)        printf(" %7.4f ",theNet->alpha[bit]);    printf("\nTotal squared error : %7.4f\n",suberr);	fclose(fPtr);							/* close the file */} /**** End of void PrintToFile() ****/void PrintResponse(struct EBPNet *theNet, double suberr, int try, int traj, int epoch, int point){    int bit;    printf("\ntraj =%3d,try =%2d ", traj, try);    printf("\nepoch=%3d,point=%2d", epoch, point);    if(theNet->biasPresent)        printf("  bias   ");    printf("    x        y    thTrailer  thCab   steering");    printf("\n         Inputs:  ");    for(bit=0; bit< theNet->numInputs;bit++)        printf(" %7.4f ",theNet->outputY[0][bit]);    printf("\nDesired outputs:  ");    if(theNet->biasPresent)        printf("  ----   ");    for(bit=theNet->biasPresent; bit< theNet->numOutputs; bit++)        printf(" %7.4f ",theNet->desired[bit]);    printf("\n Actual outputs:  ");    if(theNet->biasPresent)        printf("  ----   ");    for(bit=theNet->biasPresent; bit< theNet->numOutputs; bit++)        printf(" %7.4f ",theNet->outputY[theNet->layers-1][bit]);    printf("\n         Errors:  ");    if(theNet->biasPresent)        printf("  ----   ");    for(bit=theNet->biasPresent; bit< theNet->numOutputs; bit++)        printf(" %7.4f ",theNet->alpha[bit]);    printf("\nTotal squared error : %7.4f\n",suberr);} /* end void PrintResponse() *//* ============================================================== */void ShowWeights(struct EBPNet *theNet){   /* print out the weights */    int layer, up, down, i;    int maxUpNodes, maxDowNodes = theNet->nodesPerLayer[theNet->layers-1];    for(layer=theNet->layers-1; layer> 0 ;layer--)    {        maxUpNodes = maxDowNodes;        maxDowNodes = theNet->nodesPerLayer[layer-1];        printf("\n\nlayer %2d ",layer);        for(up=theNet->biasPresent; up<maxUpNodes; up++)            printf(" node:%2d ",up);        printf("\n");                       /* list nodes his layer */        for(i=0;i<75;i++)            printf("-");                    /* underline */        for(down=0; down<maxDowNodes; down++)        {            printf("\nnode %d: ",down);            for(up=theNet->biasPresent; up<maxUpNodes; up++)                printf(" %6.3f ",theNet->weight[layer][up][down]);        } /* next up */    } /* next layer */    printf("\n\n");} /*** End of void ShowWeights() ***/void TestOpen(const char *fName, const char *mode){	FILE *fPtr = fopen(fName, mode);	if(fPtr == NULL)	{		printf("\nCannot open file '%s' for mode '%s' - Quitting",fName,mode);		exit(1);	}	fclose(fPtr);}	/**** End of void TestOpen() ****/void SaveWeights(struct EBPNet *theNet, char *fName){ /* save the weights into a file */    int layer, up, down;    int maxUpNodes, maxDowNodes = theNet->nodesPerLayer[theNet->layers-1];	FILE *fPtr = fopen(fName,"w");	    for(layer=theNet->layers-1; layer> 0 ;layer--)    {        maxUpNodes = maxDowNodes;        maxDowNodes = theNet->nodesPerLayer[layer-1];        fprintf(fPtr, "\n\nlayer %2d ",layer);        printf("\n");                       /* list nodes his layer */        for(down=0; down<maxDowNodes; down++)        {            fprintf(fPtr,"\nnode %d: ",down);            for(up=theNet->biasPresent; up<maxUpNodes; up++)                fprintf(fPtr," %6.3f ",theNet->weight[layer][up][down]);        } /* next up */    } /* next layer */	fclose(fPtr);} /**** End of void SaveWeights() ****/void LoadWeights(struct EBPNet *theNet, char *fName){ /* save the weights into a file */    int layer, up, down, dummy;    int maxUpNodes, maxDowNodes = theNet->nodesPerLayer[theNet->layers-1];	FILE *fPtr = fopen(fName,"r");	    for(layer=theNet->layers-1; layer> 0 ;layer--)    {        maxUpNodes = maxDowNodes;        maxDowNodes = theNet->nodesPerLayer[layer-1];        fscanf(fPtr, "\n\nlayer %2d \n",&dummy);        for(down=0; down<maxDowNodes; down++)        {            fscanf(fPtr,"\nnode %d: ",&dummy);            for(up=theNet->biasPresent; up<maxUpNodes; up++)                fscanf(fPtr," %lf ",&(theNet->weight[layer][up][down]));        } /* next up */    } /* next layer */	fclose(fPtr);} /**** End of void LoadWeights() ****//* ================ Random Number Routines ========================= */void time(int *ti);                         /* SYSTEM FUNCTION - puts the time                                            (in seconds since Christ was born)                                            into the variable 'ti' *//* Need to seed the randoms - a parameter is needed. If not given then use the time as a seed. If seedrandoms() is never called, here are some defaults:  */static int x = 1 , y = 10000 , z = 3000;  /* kind of equivalent to                                             SeedRandoms(13453...) */void SeedRandoms(int v){ /* either the user supplies the seed (v >= 0),     or else (v < 0) the time(&v) is used as a seed */    if(v<0)        time(&v);     v %= 30269;     /* bring v within bounds of first generator */        x = 171 * (v % 177) - 2 * (v / 177);    if(x < 0)        x += 30269;    y = 172 * (x % 176) - 35 * (x / 176);    if(y < 0)        y += 30307;    z = 170 * (y % 178) - 63 * (y / 178);    if(z < 0)        z += 30323;} /**** End of void SeedRandoms() ****/double RanDouble(double lo, double hi){ /* returns a double random number between lo.0 and hi.0 */     double temp;    /* first generator */    x = 171 * (x % 177) - 2 * (x / 177);    if(x < 0)        x += 30269;    /* second generator */    y = 172 * (y % 176) - 35 * (y / 176);    if(y < 0)        y += 30307;    /* third generator */    z = 170 * (z % 178) - 63 * (z / 178);    if(z < 0)        z += 30323;    /* combine them */    temp = x/30269.0 + y/30307.0 + z/30323.0;    temp -= (int) (temp);   /* make it between 0.0 and 1.0 */    temp *= (hi-lo);        /* scale it */    return(temp+lo);        } /**** End of double RanDouble() ****/void Ack(char *mess){	char ch;	fflush(stdin);	printf("\n%s : press <CR>", mess);	scanf("%c",&ch);} /**** End of void Ack() ****//* ========================= Th..th..th..that's all folks!! ========== */