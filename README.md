Cannopy - C++ ANN with pybind11 interface to Python
-
- **Overview**
- **Project targets**
- **Project files**
- **Types**
- **RAM Neuron**
- **Wisard discriminator**
- **Contact**


**Overview**
`cannopy` is a C++ `pybind1l` shared library to be imported as a module into Python.
 This project builds the Python module `cannopy.so` and shared library `libCannopyLib.so`, and copies them into 
`$PYTHON_DIST_DIR`, so that `cannopy` is available as a module to be imported into Python.

For more information / explanation on how to create a C++ python module with `pybind11` see:
`https://github.com/adrianredgers/cmake-googletest-pybind11-example`

The following is a 
```
$ ./compile.sh
$ ./build/runUnitTests
$ echo $?
0
$ python
Python 2.7.12 (default, Dec  4 2017, 14:50:18) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import cannopy
>>> r = cannopy.RAM(3)
>>> addr=[1,1,0]
>>> r.lookup(addr)
0
>>> r.set(addr,1)
>>> r.lookup(addr)
1
>>> r.reset()
>>> r.lookup(addr)
0
>>> 
>>> w = cannopy.Wisard(4,1,2)
>>> r0011 = [0,0,1,1]
>>> r1100 = [1,1,0,0]
>>> r0000 = [0,0,0,0]
>>> r1111 = [1,1,1,1]
>>> w.train(r0011)
>>> w.lookup(r0011)
2
>>> w.lookup(r0000)
1
>>> w.train(r1100)
>>> w.lookup(r0000)
2
>>> w.reset()
>>> w.lookup(r0011)
0
>>> 
>>> exit()
``` 

**Project targets**
- `cannopy` - creates Python (shared library) module `cannopy.so`. Copied to `$PYTHON_DIST_DIR`.
    - Requires `libCannopyLib.so`.
- `CannopylLib` - creates shared library `libCannopyLib.so`, which is used by `cannopy.so`, unit tests and is available for any other C++.
- `*UnitTests` - executables for running unit tests outside of CLion, these use `libCannopyLib.so`. 
- Python looks for modules in `$PYTHONPATH`.
    - So we need to copy `cannopy.so` to a directory and add that directory to `$PYTHONPATH`
- If the Python shared library module `cannopy.so` needs another library then that needs to be in `$LD_LIBRARY_PATH`
    - So we need to copy `libCannopyLib.so` to a directory and add that directory to `$LD_LIBRARY_PATH`


**Project files**
- `CMakeLists.txt` - top-level CMake file that calls the `main` and `test` CMake files.
- `compile.sh` 
    - Shows how to add `$MY_PYTHON_DIST_DIR` to `$PYTHONPATH` and `$LD_LIBRARY_PATH`
    - Deletes and recreates `build` directory. 
    - Runs `cmake` and then `make`.
    - Runs the C++ googletest unit tests
- `src\include`
    - Public interfaces for `libCannopyLib.so`, used by `PyModule.cpp` and by tests.
- `src/main`
    - `CMakeLists.txt` - CMake for the main targets: `CannopyLib` and `cannopy`, copies `cannopy.so` and `libCannopyLib.so` to $PYTHON_DIST_DIR.
    - `Adrian_p.h` - private general include definitions.
    - `Adrian.cpp` - private general utilities, until I find a better home for them.
    - `PyModule.cpp` - defines interface to our C++ library in the Python module `cannopy.so`.
    - `lib/pybind11` - pybind11 source cloned from: `git@github.com:pybind/pybind11.git`.
    - <other source directories> 
- `src/test`
    - `CMakeLists.txt` - top-level CMake for test target: `*UnitTests`.
    - `lib/googletest` - googletest source code.
        - Cloned from: `git@github.com:google/googletest.git`.
    - other directories containing tests
         - **NOTE** compile.sh runs all tests labelled `<xxx>UnitTests` in the CMake files.
- `build` - temporary directory containing targets and artifacts.
    - Auto-generated, not under source code control
    - Regenerated by running `compile.sh`.
- `cmake-build-debug` - another temporary directory.
    - Annoyingly generated by CLion until you set out-of-source dir to `build` (see **CLion tips** below).

**Types**

- `UIntType` is used throughout - it is set to be an `unsigned long`.
- `AddressType` is a `std::vector` of `UIntType`, and `AddressRef` is a reference to that.
    - `AddressType` corresponds to a `list` in Python.
    - Addresses and retinas are binary vectors.
    - Addresses and retinas are binary vectors.
    

**RAM Neuron**

- A RAM Neuron is just a Random Access Memory with the number of address lines (n) you specify (max: 20).
- `2^n` address locations, which can contain a binary `1` or `0`, and are initialized to contain 0.
- You can `set` the contents of the location addressed by a binary vector of UIntType you provide.
- You can `lookup` the (binary) )contents of a location for an address you provide.
- If you `reset` a RAM Neuron it sets every address location back to 0.

**Wisard discriminator**

- A Wisard Discriminator is a set of RAM Neurons connected to an input retina, which is the image being presented to it.
- You can specify:
    - The `retinaSize` - number of inputs (pixels) in the retina.
    - The `arity`, number of address lines of each the RAM Neurons.
    - The `coverage`, the number of times the retina is sampled by the Discriminator.
- The number of RAM Neurons in the Wisard is `retinaSize x coverage / arity`.
- You can `train` the Wisard with a binary vector, which represents an image.
- You can `lookup` a trained Wisard by presenting it with a binary vector.
- You can `reset` a Wisard Discriminator, which resets each RAM Neuron within it.
   
**Contact me**
- This is my second attempt at a lot of things - CMake, CLion, googletest, python, pybind11, C++, GitHub, README ml etc.
- I would be grateful for any (non-painful) suggestions:-
    - aredgers@yahoo.com
        

